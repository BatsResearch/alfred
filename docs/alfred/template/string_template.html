<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>alfred.template.string_template API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>alfred.template.string_template</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import logging
import re
from typing import Dict, Any, Optional, Iterable, List, Union

import numpy as np
import torch

import alfred.registry as registry
from alfred.fm.query import Query, CompletionQuery, RankedQuery
from alfred.template.template import Template

logger = logging.getLogger(__name__)


class StringTemplate(Template):
    &#34;&#34;&#34;
    Prompt Template Class for Common Static Templates

    The class handles ranked scoring and completion queries for static templates.

    .. note::
        On partial label integration:
        Partial Label vote is implicitly integrated in the template.
        Users will need to specify the label maps for the partial label group numbers.
            e.g.
            Rule: Predict &#34;stripe&#34; attributes for labels [zebra, tigers].
            Label Numerical: {&#34;zebra&#34;: 1, &#34;tiger&#34;: 2, &#34;horse&#34;: 3}
            Prompt: &#34;Does the [[animal]] have stripes?&#34;

            answer_choices: &#34;yes|||no&#34;
            labels_map: {&#34;yes&#34;: 2, &#34;no&#34;: 1}

            The partial label partition would be: [[3], [1,2]]


    Methods:
        apply: apply template to an example and returns a query object
        vote: vote for the responses based on the matching function and the label maps
        update_template: update template

    Properties:
        template: template
        type: type of the template
        id: id of the template
        name: name of the template
        reference: reference
        metadata: metadata
    &#34;&#34;&#34;

    def __init__(self,
                 template: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 reference: Optional[str] = None,
                 metadata: Optional[Dict[str, Any]] = None,
                 answer_choices: Optional[Union[str, List[str]]] = None,
                 register: bool = False,
                 ):
        &#34;&#34;&#34;

        Static Prompt Template Constructor:

        :param template: template strings with keywords enclosed in *double square brackets*
                            (e.g. &#34;Does the [[animal]] have stripes?&#34;)
        :type template: str
        :param id: (optional) id of the template
        :type id: str
        :param name: (optional) name of the template
        :type name: str
        :param reference: (optional) reference of the template
        :type reference: str
        :param metadata: (optional) metadata of the template
        :type metadata: Dict[str, Any]
        :param answer_choices:  (optional) can be one of the following formats:
                                -  a ||| delimited string of choices that enumerates
                                   the possible completions. (PromptSource Convention)
                                   e.g. &#34;cat ||| dog&#34;
                                   This is for compatibility with promptsource templates
                                - a list of strings that enumerates the possible completions
                                    e.g. [&#34;cat&#34;, &#34;dog&#34;]
                               If None is given, then the template is open-ended completion.
        :type answer_choices: str
        :param register: (optional) whether to register the template to the registry
        :type register: bool
        &#34;&#34;&#34;
        self._template = template

        self._id = id
        self._name = name
        self._reference = reference
        self._metadata = metadata

        self._answer_choices = answer_choices
        self._answer_candidates = None

        self._keywords = re.findall(r&#34;\[\[(.*?)\]\]&#34;, template)

        if answer_choices:
            if isinstance(answer_choices, str):
                self._answer_candidates = [
                    _x.strip() for _x in answer_choices.split(&#34;|||&#34;)]
            elif isinstance(answer_choices, list):
                self._answer_candidates = answer_choices
            else:
                logger.warning(
                    f&#34;Unsupported answer choices format: {type(answer_choices)}&#34;)
                self._answer_choices = None

        if register:
            registry.register(self)

    def from_promptsource(self, promptsource_template):
        &#34;&#34;&#34;
        Update the template from a promptsource template

        :param promptsource_template: a promptsource template
        :type promptsource_template: Dict
        &#34;&#34;&#34;
        self._template = promptsource_template[&#39;template&#39;]
        self._id = promptsource_template[&#39;id&#39;]
        self._name = promptsource_template[&#39;name&#39;]
        self._reference = promptsource_template[&#39;reference&#39;]
        self._metadata = promptsource_template[&#39;metadata&#39;]
        self._answer_choices = promptsource_template[&#39;answer_choices&#39;]

    def apply(self,
              example: Dict,
              **kawrgs) -&gt; Query:
        &#34;&#34;&#34;
        Apply template to an example and returns a query object

        :param example: an example in format of dictionary
        :type example: Dict
        :param kawrgs: &#34;key_translator&#34; for key translation (e.g. for fields key replacements)
        :type kawrgs: Dict
        :return: query object (either CompletionQuery or RankedQuery depending on the template type)
        :rtype: Query
        &#34;&#34;&#34;
        if &#39;key_translator&#39; in kawrgs:
            key_translator = kawrgs[&#39;key_translator&#39;]
        else:
            key_translator = None

        prompt = self._template
        for key, value in example.items():
            if isinstance(value, str):
                if key_translator:
                    try:
                        k = key_translator[key]
                    except KeyError:
                        k = key
                else:
                    k = key
                prompt = prompt.replace(f&#34;[[{str(k)}]]&#34;, value)
            elif type(value) in [list, np.ndarray, torch.Tensor]:
                if isinstance(key, int):
                    if key_translator:
                        try:
                            k = key_translator[key]
                        except KeyError:
                            k = key
                    else:
                        k = key
                    prompt[k] = value
                elif isinstance(key, str) and &#39;:&#39; in key:
                    start, end = key.split(&#39;:&#39;)
                    if len(start) == 0:
                        start = 0
                    if len(end) == 0:
                        end = len(prompt)
                    r = int(end) - int(start)
                    assert r == len(
                        value), f&#34;Length of the value {len(value)} does not match the range {r}&#34;
                    prompt[int(start):int(end)] = value
                else:
                    logger.error(
                        f&#34;Key {key} is not an integer. Cannot replace with list.&#34;)
                    raise ValueError(
                        f&#34;Key {key} is not an integer. Cannot replace with list.&#34;)

        if self._answer_choices:
            return RankedQuery(
                prompt=prompt,
                candidates=self._answer_candidates)
        else:
            return CompletionQuery(prompt)

    def apply_to_dataset(self,
                         dataset: Iterable[Dict],
                         **kwargs: Any,
                         ) -&gt; Iterable[Query]:
        &#34;&#34;&#34;
        A wrapper function to apply the template to a dataset iteratively

        :param dataset: a dataset in format of a iterable of dictionary
        :type dataset: Iterable[Dict]
        :param kwargs: Additional arguments to pass to apply
        :type kwargs: Any
        :return: an iterable of query objects
        :rtype: Iterable[Query]
        &#34;&#34;&#34;
        return [self.apply(example, **kwargs) for example in dataset]

    def get_answer_choices_list(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Get answer choices list

        :return: answer choices list
        :rtype: List
        &#34;&#34;&#34;
        return self._answer_candidates

    @property
    def template(self):
        &#34;&#34;&#34;returns the template&#34;&#34;&#34;
        return self._template

    @property
    def type(self):
        &#34;&#34;&#34;returns the template type&#34;&#34;&#34;
        return self._type

    @property
    def keywords(self):
        &#34;&#34;&#34;returns the keywords&#34;&#34;&#34;
        return self._keywords

    @property
    def id(self):
        &#34;&#34;&#34;returns the template id&#34;&#34;&#34;
        return self._id

    @property
    def name(self):
        &#34;&#34;&#34;returns the template name&#34;&#34;&#34;
        return self._name

    @property
    def reference(self):
        &#34;&#34;&#34;returns the template reference&#34;&#34;&#34;
        return self._reference

    @property
    def metadata(self):
        &#34;&#34;&#34;returns the template metadata&#34;&#34;&#34;
        return self._metadata

    def serialize(self):
        &#34;&#34;&#34;
        returns the template as a json string of dictionary

        :return: json string of dictionary
        :rtype: str
        &#34;&#34;&#34;
        return json.dumps(
            {
                &#34;id&#34;: self._id,
                &#34;name&#34;: self._name,
                &#34;reference&#34;: self._reference,
                &#34;template&#34;: self._template,
                &#34;metadata&#34;: self._metadata,
                &#34;answer_choices&#34;: self._answer_choices,
            }
        )

    def deserialize(self, json_str: str) -&gt; Template:
        &#34;&#34;&#34;
        returns a template object from a json string of dictionary

        :param json_str: json string of dictionary to deserialize a string template
        :type json_str: str
        :return: template object
        &#34;&#34;&#34;
        json_str = json.loads(json_str)
        self.__init__(
            json_str[&#39;id&#39;],
            json_str[&#39;name&#39;],
            json_str[&#39;reference&#39;],
            json_str[&#39;template&#39;],
            json_str[&#39;metadata&#39;],
            json_str[&#39;answer_choices&#39;],
        )
        return self

    def __call__(self,
                 example: Dict,
                 **kawrgs: Any,
                 ) -&gt; Query:
        &#34;&#34;&#34;
        A wrapper function to apply the template to a single example

        :param example: a single example in format of a dictionary
        :type example: Dict
        :param kawrgs: Additional arguments to pass to apply
        :type kawrgs: Any
        :return: a query object
        :rtype: Query
        &#34;&#34;&#34;
        return self.apply(example, **kawrgs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="alfred.template.string_template.StringTemplate"><code class="flex name class">
<span>class <span class="ident">StringTemplate</span></span>
<span>(</span><span>template: str, id: Optional[str] = None, name: Optional[str] = None, reference: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None, answer_choices: Union[str, List[str], None] = None, register: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prompt Template Class for Common Static Templates</p>
<p>The class handles ranked scoring and completion queries for static templates.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On partial label integration:
Partial Label vote is implicitly integrated in the template.
Users will need to specify the label maps for the partial label group numbers.
e.g.
Rule: Predict "stripe" attributes for labels [zebra, tigers].
Label Numerical: {"zebra": 1, "tiger": 2, "horse": 3}
Prompt: "Does the [[animal]] have stripes?"</p>
<pre><code>answer_choices: "yes|||no"
labels_map: {"yes": 2, "no": 1}

The partial label partition would be: [[3], [1,2]]
</code></pre>
</div>
<h2 id="methods">Methods</h2>
<p>apply: apply template to an example and returns a query object
vote: vote for the responses based on the matching function and the label maps
update_template: update template</p>
<h2 id="properties">Properties</h2>
<p>template: template
type: type of the template
id: id of the template
name: name of the template
reference: reference
metadata: metadata</p>
<p>Static Prompt Template Constructor:</p>
<p>:param template: template strings with keywords enclosed in <em>double square brackets</em>
(e.g. "Does the [[animal]] have stripes?")
:type template: str
:param id: (optional) id of the template
:type id: str
:param name: (optional) name of the template
:type name: str
:param reference: (optional) reference of the template
:type reference: str
:param metadata: (optional) metadata of the template
:type metadata: Dict[str, Any]
:param answer_choices:
(optional) can be one of the following formats:
-
a ||| delimited string of choices that enumerates
the possible completions. (PromptSource Convention)
e.g. "cat ||| dog"
This is for compatibility with promptsource templates
- a list of strings that enumerates the possible completions
e.g. ["cat", "dog"]
If None is given, then the template is open-ended completion.
:type answer_choices: str
:param register: (optional) whether to register the template to the registry
:type register: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringTemplate(Template):
    &#34;&#34;&#34;
    Prompt Template Class for Common Static Templates

    The class handles ranked scoring and completion queries for static templates.

    .. note::
        On partial label integration:
        Partial Label vote is implicitly integrated in the template.
        Users will need to specify the label maps for the partial label group numbers.
            e.g.
            Rule: Predict &#34;stripe&#34; attributes for labels [zebra, tigers].
            Label Numerical: {&#34;zebra&#34;: 1, &#34;tiger&#34;: 2, &#34;horse&#34;: 3}
            Prompt: &#34;Does the [[animal]] have stripes?&#34;

            answer_choices: &#34;yes|||no&#34;
            labels_map: {&#34;yes&#34;: 2, &#34;no&#34;: 1}

            The partial label partition would be: [[3], [1,2]]


    Methods:
        apply: apply template to an example and returns a query object
        vote: vote for the responses based on the matching function and the label maps
        update_template: update template

    Properties:
        template: template
        type: type of the template
        id: id of the template
        name: name of the template
        reference: reference
        metadata: metadata
    &#34;&#34;&#34;

    def __init__(self,
                 template: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 reference: Optional[str] = None,
                 metadata: Optional[Dict[str, Any]] = None,
                 answer_choices: Optional[Union[str, List[str]]] = None,
                 register: bool = False,
                 ):
        &#34;&#34;&#34;

        Static Prompt Template Constructor:

        :param template: template strings with keywords enclosed in *double square brackets*
                            (e.g. &#34;Does the [[animal]] have stripes?&#34;)
        :type template: str
        :param id: (optional) id of the template
        :type id: str
        :param name: (optional) name of the template
        :type name: str
        :param reference: (optional) reference of the template
        :type reference: str
        :param metadata: (optional) metadata of the template
        :type metadata: Dict[str, Any]
        :param answer_choices:  (optional) can be one of the following formats:
                                -  a ||| delimited string of choices that enumerates
                                   the possible completions. (PromptSource Convention)
                                   e.g. &#34;cat ||| dog&#34;
                                   This is for compatibility with promptsource templates
                                - a list of strings that enumerates the possible completions
                                    e.g. [&#34;cat&#34;, &#34;dog&#34;]
                               If None is given, then the template is open-ended completion.
        :type answer_choices: str
        :param register: (optional) whether to register the template to the registry
        :type register: bool
        &#34;&#34;&#34;
        self._template = template

        self._id = id
        self._name = name
        self._reference = reference
        self._metadata = metadata

        self._answer_choices = answer_choices
        self._answer_candidates = None

        self._keywords = re.findall(r&#34;\[\[(.*?)\]\]&#34;, template)

        if answer_choices:
            if isinstance(answer_choices, str):
                self._answer_candidates = [
                    _x.strip() for _x in answer_choices.split(&#34;|||&#34;)]
            elif isinstance(answer_choices, list):
                self._answer_candidates = answer_choices
            else:
                logger.warning(
                    f&#34;Unsupported answer choices format: {type(answer_choices)}&#34;)
                self._answer_choices = None

        if register:
            registry.register(self)

    def from_promptsource(self, promptsource_template):
        &#34;&#34;&#34;
        Update the template from a promptsource template

        :param promptsource_template: a promptsource template
        :type promptsource_template: Dict
        &#34;&#34;&#34;
        self._template = promptsource_template[&#39;template&#39;]
        self._id = promptsource_template[&#39;id&#39;]
        self._name = promptsource_template[&#39;name&#39;]
        self._reference = promptsource_template[&#39;reference&#39;]
        self._metadata = promptsource_template[&#39;metadata&#39;]
        self._answer_choices = promptsource_template[&#39;answer_choices&#39;]

    def apply(self,
              example: Dict,
              **kawrgs) -&gt; Query:
        &#34;&#34;&#34;
        Apply template to an example and returns a query object

        :param example: an example in format of dictionary
        :type example: Dict
        :param kawrgs: &#34;key_translator&#34; for key translation (e.g. for fields key replacements)
        :type kawrgs: Dict
        :return: query object (either CompletionQuery or RankedQuery depending on the template type)
        :rtype: Query
        &#34;&#34;&#34;
        if &#39;key_translator&#39; in kawrgs:
            key_translator = kawrgs[&#39;key_translator&#39;]
        else:
            key_translator = None

        prompt = self._template
        for key, value in example.items():
            if isinstance(value, str):
                if key_translator:
                    try:
                        k = key_translator[key]
                    except KeyError:
                        k = key
                else:
                    k = key
                prompt = prompt.replace(f&#34;[[{str(k)}]]&#34;, value)
            elif type(value) in [list, np.ndarray, torch.Tensor]:
                if isinstance(key, int):
                    if key_translator:
                        try:
                            k = key_translator[key]
                        except KeyError:
                            k = key
                    else:
                        k = key
                    prompt[k] = value
                elif isinstance(key, str) and &#39;:&#39; in key:
                    start, end = key.split(&#39;:&#39;)
                    if len(start) == 0:
                        start = 0
                    if len(end) == 0:
                        end = len(prompt)
                    r = int(end) - int(start)
                    assert r == len(
                        value), f&#34;Length of the value {len(value)} does not match the range {r}&#34;
                    prompt[int(start):int(end)] = value
                else:
                    logger.error(
                        f&#34;Key {key} is not an integer. Cannot replace with list.&#34;)
                    raise ValueError(
                        f&#34;Key {key} is not an integer. Cannot replace with list.&#34;)

        if self._answer_choices:
            return RankedQuery(
                prompt=prompt,
                candidates=self._answer_candidates)
        else:
            return CompletionQuery(prompt)

    def apply_to_dataset(self,
                         dataset: Iterable[Dict],
                         **kwargs: Any,
                         ) -&gt; Iterable[Query]:
        &#34;&#34;&#34;
        A wrapper function to apply the template to a dataset iteratively

        :param dataset: a dataset in format of a iterable of dictionary
        :type dataset: Iterable[Dict]
        :param kwargs: Additional arguments to pass to apply
        :type kwargs: Any
        :return: an iterable of query objects
        :rtype: Iterable[Query]
        &#34;&#34;&#34;
        return [self.apply(example, **kwargs) for example in dataset]

    def get_answer_choices_list(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Get answer choices list

        :return: answer choices list
        :rtype: List
        &#34;&#34;&#34;
        return self._answer_candidates

    @property
    def template(self):
        &#34;&#34;&#34;returns the template&#34;&#34;&#34;
        return self._template

    @property
    def type(self):
        &#34;&#34;&#34;returns the template type&#34;&#34;&#34;
        return self._type

    @property
    def keywords(self):
        &#34;&#34;&#34;returns the keywords&#34;&#34;&#34;
        return self._keywords

    @property
    def id(self):
        &#34;&#34;&#34;returns the template id&#34;&#34;&#34;
        return self._id

    @property
    def name(self):
        &#34;&#34;&#34;returns the template name&#34;&#34;&#34;
        return self._name

    @property
    def reference(self):
        &#34;&#34;&#34;returns the template reference&#34;&#34;&#34;
        return self._reference

    @property
    def metadata(self):
        &#34;&#34;&#34;returns the template metadata&#34;&#34;&#34;
        return self._metadata

    def serialize(self):
        &#34;&#34;&#34;
        returns the template as a json string of dictionary

        :return: json string of dictionary
        :rtype: str
        &#34;&#34;&#34;
        return json.dumps(
            {
                &#34;id&#34;: self._id,
                &#34;name&#34;: self._name,
                &#34;reference&#34;: self._reference,
                &#34;template&#34;: self._template,
                &#34;metadata&#34;: self._metadata,
                &#34;answer_choices&#34;: self._answer_choices,
            }
        )

    def deserialize(self, json_str: str) -&gt; Template:
        &#34;&#34;&#34;
        returns a template object from a json string of dictionary

        :param json_str: json string of dictionary to deserialize a string template
        :type json_str: str
        :return: template object
        &#34;&#34;&#34;
        json_str = json.loads(json_str)
        self.__init__(
            json_str[&#39;id&#39;],
            json_str[&#39;name&#39;],
            json_str[&#39;reference&#39;],
            json_str[&#39;template&#39;],
            json_str[&#39;metadata&#39;],
            json_str[&#39;answer_choices&#39;],
        )
        return self

    def __call__(self,
                 example: Dict,
                 **kawrgs: Any,
                 ) -&gt; Query:
        &#34;&#34;&#34;
        A wrapper function to apply the template to a single example

        :param example: a single example in format of a dictionary
        :type example: Dict
        :param kawrgs: Additional arguments to pass to apply
        :type kawrgs: Any
        :return: a query object
        :rtype: Query
        &#34;&#34;&#34;
        return self.apply(example, **kawrgs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="alfred.template.template.Template" href="template.html#alfred.template.template.Template">Template</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="alfred.template.string_template.StringTemplate.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>returns the template id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;returns the template id&#34;&#34;&#34;
    return self._id</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.keywords"><code class="name">var <span class="ident">keywords</span></code></dt>
<dd>
<div class="desc"><p>returns the keywords</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def keywords(self):
    &#34;&#34;&#34;returns the keywords&#34;&#34;&#34;
    return self._keywords</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>returns the template metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self):
    &#34;&#34;&#34;returns the template metadata&#34;&#34;&#34;
    return self._metadata</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>returns the template name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;returns the template name&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.reference"><code class="name">var <span class="ident">reference</span></code></dt>
<dd>
<div class="desc"><p>returns the template reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reference(self):
    &#34;&#34;&#34;returns the template reference&#34;&#34;&#34;
    return self._reference</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>returns the template</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def template(self):
    &#34;&#34;&#34;returns the template&#34;&#34;&#34;
    return self._template</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>returns the template type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self):
    &#34;&#34;&#34;returns the template type&#34;&#34;&#34;
    return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="alfred.template.string_template.StringTemplate.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, example: Dict[~KT, ~VT], **kawrgs) ‑> <a title="alfred.fm.query.query.Query" href="../fm/query/query.html#alfred.fm.query.query.Query">Query</a></span>
</code></dt>
<dd>
<div class="desc"><p>Apply template to an example and returns a query object</p>
<p>:param example: an example in format of dictionary
:type example: Dict
:param kawrgs: "key_translator" for key translation (e.g. for fields key replacements)
:type kawrgs: Dict
:return: query object (either CompletionQuery or RankedQuery depending on the template type)
:rtype: Query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self,
          example: Dict,
          **kawrgs) -&gt; Query:
    &#34;&#34;&#34;
    Apply template to an example and returns a query object

    :param example: an example in format of dictionary
    :type example: Dict
    :param kawrgs: &#34;key_translator&#34; for key translation (e.g. for fields key replacements)
    :type kawrgs: Dict
    :return: query object (either CompletionQuery or RankedQuery depending on the template type)
    :rtype: Query
    &#34;&#34;&#34;
    if &#39;key_translator&#39; in kawrgs:
        key_translator = kawrgs[&#39;key_translator&#39;]
    else:
        key_translator = None

    prompt = self._template
    for key, value in example.items():
        if isinstance(value, str):
            if key_translator:
                try:
                    k = key_translator[key]
                except KeyError:
                    k = key
            else:
                k = key
            prompt = prompt.replace(f&#34;[[{str(k)}]]&#34;, value)
        elif type(value) in [list, np.ndarray, torch.Tensor]:
            if isinstance(key, int):
                if key_translator:
                    try:
                        k = key_translator[key]
                    except KeyError:
                        k = key
                else:
                    k = key
                prompt[k] = value
            elif isinstance(key, str) and &#39;:&#39; in key:
                start, end = key.split(&#39;:&#39;)
                if len(start) == 0:
                    start = 0
                if len(end) == 0:
                    end = len(prompt)
                r = int(end) - int(start)
                assert r == len(
                    value), f&#34;Length of the value {len(value)} does not match the range {r}&#34;
                prompt[int(start):int(end)] = value
            else:
                logger.error(
                    f&#34;Key {key} is not an integer. Cannot replace with list.&#34;)
                raise ValueError(
                    f&#34;Key {key} is not an integer. Cannot replace with list.&#34;)

    if self._answer_choices:
        return RankedQuery(
            prompt=prompt,
            candidates=self._answer_candidates)
    else:
        return CompletionQuery(prompt)</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.apply_to_dataset"><code class="name flex">
<span>def <span class="ident">apply_to_dataset</span></span>(<span>self, dataset: Iterable[Dict[~KT, ~VT]], **kwargs: Any) ‑> Iterable[<a title="alfred.fm.query.query.Query" href="../fm/query/query.html#alfred.fm.query.query.Query">Query</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper function to apply the template to a dataset iteratively</p>
<p>:param dataset: a dataset in format of a iterable of dictionary
:type dataset: Iterable[Dict]
:param kwargs: Additional arguments to pass to apply
:type kwargs: Any
:return: an iterable of query objects
:rtype: Iterable[Query]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_to_dataset(self,
                     dataset: Iterable[Dict],
                     **kwargs: Any,
                     ) -&gt; Iterable[Query]:
    &#34;&#34;&#34;
    A wrapper function to apply the template to a dataset iteratively

    :param dataset: a dataset in format of a iterable of dictionary
    :type dataset: Iterable[Dict]
    :param kwargs: Additional arguments to pass to apply
    :type kwargs: Any
    :return: an iterable of query objects
    :rtype: Iterable[Query]
    &#34;&#34;&#34;
    return [self.apply(example, **kwargs) for example in dataset]</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, json_str: str) ‑> <a title="alfred.template.template.Template" href="template.html#alfred.template.template.Template">Template</a></span>
</code></dt>
<dd>
<div class="desc"><p>returns a template object from a json string of dictionary</p>
<p>:param json_str: json string of dictionary to deserialize a string template
:type json_str: str
:return: template object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self, json_str: str) -&gt; Template:
    &#34;&#34;&#34;
    returns a template object from a json string of dictionary

    :param json_str: json string of dictionary to deserialize a string template
    :type json_str: str
    :return: template object
    &#34;&#34;&#34;
    json_str = json.loads(json_str)
    self.__init__(
        json_str[&#39;id&#39;],
        json_str[&#39;name&#39;],
        json_str[&#39;reference&#39;],
        json_str[&#39;template&#39;],
        json_str[&#39;metadata&#39;],
        json_str[&#39;answer_choices&#39;],
    )
    return self</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.from_promptsource"><code class="name flex">
<span>def <span class="ident">from_promptsource</span></span>(<span>self, promptsource_template)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the template from a promptsource template</p>
<p>:param promptsource_template: a promptsource template
:type promptsource_template: Dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_promptsource(self, promptsource_template):
    &#34;&#34;&#34;
    Update the template from a promptsource template

    :param promptsource_template: a promptsource template
    :type promptsource_template: Dict
    &#34;&#34;&#34;
    self._template = promptsource_template[&#39;template&#39;]
    self._id = promptsource_template[&#39;id&#39;]
    self._name = promptsource_template[&#39;name&#39;]
    self._reference = promptsource_template[&#39;reference&#39;]
    self._metadata = promptsource_template[&#39;metadata&#39;]
    self._answer_choices = promptsource_template[&#39;answer_choices&#39;]</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.get_answer_choices_list"><code class="name flex">
<span>def <span class="ident">get_answer_choices_list</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get answer choices list</p>
<p>:return: answer choices list
:rtype: List</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_answer_choices_list(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Get answer choices list

    :return: answer choices list
    :rtype: List
    &#34;&#34;&#34;
    return self._answer_candidates</code></pre>
</details>
</dd>
<dt id="alfred.template.string_template.StringTemplate.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the template as a json string of dictionary</p>
<p>:return: json string of dictionary
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self):
    &#34;&#34;&#34;
    returns the template as a json string of dictionary

    :return: json string of dictionary
    :rtype: str
    &#34;&#34;&#34;
    return json.dumps(
        {
            &#34;id&#34;: self._id,
            &#34;name&#34;: self._name,
            &#34;reference&#34;: self._reference,
            &#34;template&#34;: self._template,
            &#34;metadata&#34;: self._metadata,
            &#34;answer_choices&#34;: self._answer_choices,
        }
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="alfred.template" href="index.html">alfred.template</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="alfred.template.string_template.StringTemplate" href="#alfred.template.string_template.StringTemplate">StringTemplate</a></code></h4>
<ul class="">
<li><code><a title="alfred.template.string_template.StringTemplate.apply" href="#alfred.template.string_template.StringTemplate.apply">apply</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.apply_to_dataset" href="#alfred.template.string_template.StringTemplate.apply_to_dataset">apply_to_dataset</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.deserialize" href="#alfred.template.string_template.StringTemplate.deserialize">deserialize</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.from_promptsource" href="#alfred.template.string_template.StringTemplate.from_promptsource">from_promptsource</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.get_answer_choices_list" href="#alfred.template.string_template.StringTemplate.get_answer_choices_list">get_answer_choices_list</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.id" href="#alfred.template.string_template.StringTemplate.id">id</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.keywords" href="#alfred.template.string_template.StringTemplate.keywords">keywords</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.metadata" href="#alfred.template.string_template.StringTemplate.metadata">metadata</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.name" href="#alfred.template.string_template.StringTemplate.name">name</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.reference" href="#alfred.template.string_template.StringTemplate.reference">reference</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.serialize" href="#alfred.template.string_template.StringTemplate.serialize">serialize</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.template" href="#alfred.template.string_template.StringTemplate.template">template</a></code></li>
<li><code><a title="alfred.template.string_template.StringTemplate.type" href="#alfred.template.string_template.StringTemplate.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>