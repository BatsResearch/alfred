import os
import sqlite3
import logging
from typing import Optional, Any, List

import pandas as pd

from alfred.client.cache.cache import Cache

logger = logging.getLogger(__name__)

class SQLiteCache(Cache):
    """
    In-memory/local storage key-value store caching system using SQLite

    The cache operates in memory and is periodically saved to disk.

    The cache's main components are a 3-column table that contains:
        - prompt: the serialized prompt that was used to generate the response
        - metadata: the metadata associated with the prompt
        - response: the serialized response generated by the prompt

    # TODO: Make response (de)serializable such that it fits in to the entries
    """

    def __init__(self,
                 session_name: str = "prompt-session-0",
                 cache_location: Optional[str] = None,
                 ):
        """
        Initialize the SQLite-based cache

        :param session_name: The name of the session to use, defaults to "prompt-session-0"
        :type session_name: str
        :param cache_location: (Optional) The location of the cache file
        :type cache_location: str
        """

        self.cache_location = cache_location or f".cache/{session_name}.sqlite3"
        self.cache_db = sqlite3.connect(':memory:', check_same_thread=False)

        # check if cache exists
        if os.path.exists(self.cache_location):
            con = sqlite3.connect(self.cache_location)
            con.backup(self.cache_db)
            con.close()
        else:
            # create cache
            self.cache_db.execute("CREATE TABLE prompt_cache (prompt text," +
                                  " metadata text, response text, " +
                                  " PRIMARY KEY (prompt, metadata));")
            self.cache_db.commit()

    def write(self, prompt: str,
              response: str,
              metadata: Optional[str] = None):
        """
        Write a prompt, response, and metadata record to the cache

        :param prompt: The prompt to write
        :type prompt: str
        :param response: The response to write
        :type response: str
        :param metadata: (optional) The metadata to write
        :type metadata: str
        """
        self.cache_db.execute(
            'INSERT INTO prompt_cache (prompt, metadata, response) VALUES (?, ?, ?)',
            (prompt,
             metadata,
             response))
        self.cache_db.commit()

    def write_batch(self, prompts: List[str], responses: List[str], metadata: Optional[str] = None):
        """
        Write a batch of serialized prompt, serialized response, and metadata records to the cache

        :param prompts: The serialized prompts to write
        :type prompts: List[str]
        :param responses: The serialized responses to write
        :type responses: List[str]
        :param metadata: (optional) The metadata to write
        :type metadata: str
        """
        if metadata is None:
            metadata = ['{}'] * len(prompts)
        else:
            metadata = [metadata] * len(prompts)
        self.cache_db.executemany(
            'INSERT INTO prompt_cache (prompt, metadata, response) VALUES (?, ?, ?)', zip(
                prompts, metadata, responses))
        self.cache_db.commit()

    def fetch_data(self, sql_suffix: str, *args: Any) -> List:
        """
        Wrapper function for fetching data with specific sql suffix and args

        :param sql_suffix: The sql suffix to use
        :type sql_suffix: str
        :param args: The args to use
        :type args: Any
        :return: The fetched data records as List. Will return empty list if no records found
        :rtype: List
        """

        cursor = self.cache_db.cursor()
        sqlite_select_query = """SELECT * from prompt_cache """ + sql_suffix
        cursor.execute(sqlite_select_query, *args)
        records = cursor.fetchall()
        cursor.close()
        return records

    def read_by_prompt(self, prompt: str) -> List:
        """
        Read records from the cache by prompt

        :param prompt: The prompt to read
        :type prompt: str
        :return: The records as a list
        :rtype: List
        """
        return self.fetch_data(f"WHERE prompt = ?", prompt)

    def read_by_prompt_and_metadata(self, prompt: str, metadata: str) -> List:
        """
        Read records from the cache by prompt and metadata

        :param prompt: The prompt to read
        :type prompt: str
        :param metadata: The metadata to read
        :type metadata: str
        :return: The records as a list
        :rtype: List
        """
        return self.fetch_data(
            f"WHERE prompt = ? AND metadata = ?", (prompt, metadata))

    def read_by_prompts_and_metadata(self, prompts: List[str], metadata: str) -> List:
        """
        Read records from the cache by list of prompts and metadata

        :param prompts: The list of prompts to read
        :type prompts: List[str]
        :param metadata: The metadata to read
        :type metadata: str
        :return: The records as a list
        :rtype: List
        """
        return self.fetch_data(
            f"WHERE prompt IN ({','.join('?' * len(prompts))}) AND metadata = ?",
            (*prompts,
             metadata))

    def read_by_metadata(self, metadata: str) -> List:
        """
        Read records from the cache by metadata

        :param metadata: The metadata to read
        :type metadata: str
        :return: The records as a list
        :rtype: List
        """
        return self.fetch_data(f"WHERE metadata = ?", metadata)

    def read(self, prompt: str, metadata: Optional[str] = None) -> List:
        """
        Read records from the cache by prompt and metadata

        :param prompt: The prompt to read
        :type prompt: str
        :param metadata: (optional) The metadata to read
        :type metadata: str
        :return: The records as a list
        :rtype: List
        """
        response = self.read_by_prompt_and_metadata(
            prompt, metadata) if metadata else self.read_by_prompt(prompt)
        try:
            return response[0][2]
        except IndexError:
            return None

    def read_batch(self, prompts: List[str], metadata: Optional[str] = None) -> List:
        """
        Read a batch of values from the cache by prompt

        return responses, new_q_idx, _new_queries

        TODO: Need to reimplement this to support unided responses

        :param prompts: The prompts to read
        :type prompts: List[str]
        :param metadata: (optional) The metadata to read
        :type metadata: str
        :return: The responses as a list
        :rtype: List
        """
        records = self.read_by_prompts_and_metadata(prompts, metadata)
        responses = [None] * len(prompts)
        new_q_idx = []
        _new_queries = []
        for i, record in enumerate(records):
            responses[i] = record[2]
            if responses[i] is None:
                new_q_idx.append(i)
                _new_queries.append(prompts[i])
        return responses, new_q_idx, _new_queries

    def to_pandas(self) -> pd.DataFrame:
        """
        Return the cache db as a pandas dataframe

        :return: The cache db as a pandas dataframe
        :rtype: pd.DataFrame
        """
        return pd.read_sql_query("SELECT * FROM prompt_cache", self.cache_db)

    def save(self, path: Optional[str] = None):
        """
        Save the cache to a file

        :param path: (optional) The path to save the cache to. If not provided, will save to the path provided at initialization
        :type path: str
        """
        self.cache_db.backup(sqlite3.connect(path or self.cache_location))

    def load(self, path: Optional[str] = None):
        """
        Load the cache from a file

        :param path: (optional) The path to load the cache from. If not provided, will load from the path provided at initialization
        :type path: str
        """
        self.cache_db = sqlite3.connect(':memory:', check_same_thread=False)
        if os.path.exists(self.cache_location):
            con = sqlite3.connect(self.cache_location)
            con.backup(self.cache_db)
            con.close()
        else:
            logger.warning("Cache file does not exist")

